'''
Created on Nov 20, 2015

@author: prag717
'''

import simplicialHomology as sh


def closure(complx):
    ## returns the closure of the given complex - adds all of the sublists
    n = max([len(lst) for lst in complx])
    k = n-1
    A1 = []
    while k >= 0:
        A1 += sh.ksimplices(complx,k)
        k += -1
    return A1

def sstar(toplexes, complx):
    ## computes the star of the complex in the ASC generated by the toplexes
    i = 0
    asc = closure(toplexes)

    A = list(complx)
    i += 1
    for simplex in complx:
        B = sh.star(asc,simplex)
        i+= 1
        for b in B:
            if not sh.simpcluded(b,A):
                A.append(b)
    return A

###### ToDo: make a neighborhood function which computes does the recursion to construct
######       the correct complx for locHomTable

def locHomTable(toplexes, ascdict={}, neighborhood = 1, ofile = None):
#  Computes the local homology for all faces in the ASC generated by the toplexes
#  and returns a table of the dimensions of H1, H2, and H3
#  Takes a neighborhood size 0,1,2, and an output file name
#  if nodes are named, this can go in ascdict={nodeNumber:"name"} for the table
#  otherwise names will be given by the concatenation of the index numbers

    k = 1
    ASC = closure(toplexes)
    if ofile == None:
        print " ", "\t\t", "H1" , "\t" , "H2", "\t", "H3", "\t\t", "FACE"
        print "-"*50
    else:
        ofile.write(" \t\t" + "H1" + "\t" + "H2" + "\t" + "H3" + "\t\t" + "name" + "\n")

    for splx in ASC:

        if neighborhood == 0:
            complx = [splx]
        elif neighborhood == 1:
            complx = closure([splx])
        else:
            complx = closure(sstar(toplexes, closure([splx])))
        A = sstar(toplexes, complx)

        H1=sh.localHomology(toplexes,1,A).shape[1]
        H2=sh.localHomology(toplexes,2,A).shape[1]
        H3=sh.localHomology(toplexes,3,A).shape[1]


        name = ""
        if ascdict != {}:
            for idx in range(len(A[0])):
                name += ascdict[A[0][idx]]

        if name == "":
            name = ','.join(map(str,splx))

        if ofile == None:
            print  k, "\t\t", H1 , "\t" , H2, "\t", H3, "\t\t", name
            k += 1
        else:
            ofile.write(str(k) + "\t\t" + str(H1) + "\t" + str(H2) + "\t" + str(H3) + "\t\t" + str(name) + "\n")
            k += 1


############## 7x6 Example  ###############################################
#toplexes = [[0,1],[0,2],[1,2,3],[2,3,4,5],[5,6]]
#flagtoplexes = [[0,1,2],[1,2,3],[2,3,4,5],[5,6]]
#ascdict = {0:"E", 1:"C", 2:"A", 3:"K", 4:"V", 5:"T2", 6:"T1"}

#print("Local Homology of original 7 by 6 diagram")
#locHomTable(toplexes, ascdict)
#print
#print("Local Homology of flag complex generated by original 7 by 6 diagram")
#locHomTable(sh.flag(toplexes),ascdict)


############################################################################

import igraph as ig
from datetime import datetime
import time

def run_graph(graph_file, output_file, neighborhood, flag = None):
    print "==== New graph ===="
    print "Input:", graph_file
    print "Output:", output_file
    print "Neighborhood:", neighborhood
    print ""

    print "Loading graph"
    print "Start time: %s" % (datetime.now())
    g = ig.load(graph_file)
    print "End time: %s" % (datetime.now())

    gflag = None
    if flag == None:
        print "Creating flag complex"
        print "Start time: %s" % (datetime.now())
        gedges = list(g.get_edgelist())
        gedgelist = map(list,gedges)
        gflag = sh.flag(gedgelist,4)
        print "End time: %s" % (datetime.now())
    else:
        print "Using passed in flag complex"
        gflag = flag

    print "Finding the local homology"
    print "Start time: %s" % (datetime.now())
    for n in range(neighborhood+1):
        graph = graph_file.split("/")[-1]
        ofile = open(output_file, 'w')
        ofile.write("Local Homology (neighborhood=%d) of flag complex generated by %s\n" % (n, graph))
        locHomTable(gflag, {}, n, ofile)
    print "End time: %s" % (datetime.now())
    print "\n"

    return gflag

# Input graphs
karate  = "/home/rans402/Desktop/homology/graphs/karate.gml"
powLaw  = "/home/rans402/Desktop/homology/graphs/BA40.gml"
poisson = "/home/rans402/Desktop/homology/graphs/ER40.gml"

# Output files
karate_out = "/home/rans402/Desktop/homology/mrpythonoutput/karateOutput_%d.txt"
powLaw_out = "/home/rans402/Desktop/homology/mrpythonoutput/powerlawOutput_%d.txt"
poiss_out  = "/home/rans402/Desktop/homology/mrpythonoutput/poissonOutput_%d.txt"

# Record the total time taken for each run
times = [0]*3

#############  Karate Graph ###############################################################
# Run karate graph for neighborhood size 0, 1, 2
#flag = None
#for n in range(3):
#    start = time.time()
#    # We only need to compute the flag complex once.
#    # Don't waste time computing it for every neighborhood size.
#    flag = run_graph(karate,
#                     karate_out % (n),
#                     n,
#                     flag)
#    times[n] = time.time() - start
#
#print "\nThe total run time for each neighborhood size"
#for n, time in enumerate(times):
#    print "%d: %f" % (n, time)

# karate = ig.load("/Users/prag717/documents/g8/mrPythonCode/mrgithub/karate.gml")
# print ig.summary(karate)
# print karate
# print len(karate.get_edgelist())
# print karate.es[77].attributes()
# print karate.vs.degree()
# print karate.edge_betweenness()

#############  PowerLaw Distribution Graph ################################################
#flag = None
#for n in range(3):
#    start = time.time()
#    # We only need to compute the flag complex once.
#    # Don't waste time computing it for every neighborhood size.
#    flag = run_graph(powLaw,
#                     powLaw_out % (n),
#                     n,
#                     flag)
#    times[n] = time.time() - start
#
#print "\nThe total run time for each neighborhood size"
#for n, time in enumerate(times):
#    print "%d: %f" % (n, time)

#############  Poisson Distribution Graph ################################################
#flag = None
#for n in range(3):
#    start = time.time()
#    # We only need to compute the flag complex once.
#    # Don't waste time computing it for every neighborhood size.
#    flag = run_graph(poisson,
#                     poiss_out % (n),
#                     n,
#                     flag)
#    times[n] = time.time() - start
#
#print "\nThe total run time for each neighborhood size"
#for n, time in enumerate(times):
#    print "%d: %f" % (n, time)

#############################################################################
